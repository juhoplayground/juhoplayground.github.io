---
layout: post
title: 바이브 코딩
author: 'Juho'
date: 2025-07-02 09:00:00 +0900
categories: [VibeCoding]
tags: [VibeCoding, LLM, Coding]
pin: True
toc : True
---

<style>
  th{
    font-weight: bold;
    text-align: center;
    background-color: white;
  }
  td{
    background-color: white;
  }

</style>

## 목차
1. [바이브 코딩?](#바이브-코딩)
2. [장점](#장점)
3. [단점](#단점)
4. [프로그래머로 살아가기 위해서](#프로그래머로-살아가기-위해서)

## 바이브 코딩?
2025년 2월 안드레이 카파시(Andrej Karpathy)가 X에 vibe coding”이라고 하며 [포스팅](https://x.com/karpathy/status/1886192184808149383){:target="_blank"}을 함
2025년 3월에는 Merriam-Webster 사전에 “slang & trending” 용어로 등재되며 공식화  
2025년 5월에는 [스타트업 25%가 코드베이스의 95% 이상을 AI로 작성](https://techcrunch.com/2025/03/06/a-quarter-of-startups-in-ycs-current-cohort-have-codebases-that-are-almost-entirely-ai-generated/){:target="_blank"}했다는 기사도 있다.  


핵심 개념
- 자연어 기반 코딩 : 자연어로 문제나 기능을 구현을 지시하면 AI가 코드를 생성해 주는 방식
- AI와의 협업: AI가 생성한 코드를 기반으로 피드백을 주고받으며 원하는 결과물을 점차 구체화하고 발전
- 의도에 집중: 구현의 세부적인 문법이나 기술적인 '방법'보다는 소프트웨어의 목적과 사용자 경험이라는 '무엇'에 더 집중


## 장점  
### 1) 높은 접근성  
- 비전문가도 자연어 아이디어만으로 소프트웨어 제작 가능 → 개발 인력 수급난 완화 및 진입장벽 제거  

### 2) 신속한 개발 및 프로토타이핑  
- 반복적·상용구 작업 자동화 → MVP 제작 속도 대폭 향상  

### 3) 생산성 향상  
- AI가 보일러플레이트·기초 로직 처리  

### 4) 유연한 개발 과정  
- 반복적인 피드백 사이클로 새로운 해결책 발견  

### 5) 학습·탐색 도구  
- 낯선 언어·프레임워크 실험 시 학습 곡선 완화  



## 단점  
### 1) 잘못된 패턴 반복
- 과거의 안티패턴이나 낡은 스타일을 그대로 재생산

### 2) 개발 사고력 약화
- 문제 인식·추상화 능력 퇴화

### 3) 시간 낭비 및 재작업 증가
- 목적에 맞지 않아 전체를 다시 설계

### 4) 비용 증가
- 컨텍스트 윈도우 확대에 따른 API 호출 토큰 비용 급증

### 5) 운영·인프라 지식 한계
- 백엔드 인프라·운영 자동화 미흡 → 개발 어려움


## 전망
1) AI 코딩과 로우코드/노코드 툴 결합으로 비전문가 참여 확대  
2) 개발자의 역할 변화: AI 활용·프롬프트 설계·시스템 아키텍처와 문제 해결 역량이 중요    
3) 새로운 비즈니스 모델 창출: 소수 인력으로도 아이디어를 빠르게 구현  
4) 디지털 전환 가속화: AI 기반 개발로 필요한 애플리케이션·서비스를 빠르게 구축  
5) 하이브리드 개발 파이프라인 : [Vibe Coding ↔ Agentic Coding 통합 사례 연구](https://arxiv.org/abs/2505.19443){:target="_blank"}    

## 바이브 코딩을 해보고 나서
바이브 코딩이 무작정 안좋다고는 생각하지 않는다.  
코딩을 하는 단계를 3가지 단계로 분류해서 생각해봤다.  
0~10% 단계 : 이때는 모르는 내용을 학습하기는 좋으나, 최신 버전에 맞춰서 답변하는지 옳게 대답하는지 정확히 내가 모름  
→ 실행이 되면 일단 문제가 없다고 생각하고 진행하게 됨  
  
10~90% : 피드백 받고 수정하고 계속 진행하면서 무언가 만들어지기는 해서 좋음   
하지만 목적에 맞게 설계가 잘 안되면 처음부터 다시 해야하는 번거로움이 생김  
- 큰 틀에서 작은 내용 단위로 만들경우  : 세부 구현이 잘 안됨  
- 작은 내용에서 큰 틀을 만드려고 하는 경우 : 아키텍처 일관성 부족  
  
90~100% : 전체 컨텍스트를 이해하지 못하여 잘못된 내용으로 수정, 디버깅하는데 어려워 고도화 문제  

각 단계에서 장,단점이 존재하고 검토, 수정 과정이 필요해서 딸깍으로 코드가 나오지는 않았다.  
장점과 단점을 명확히 이해하고 적절하게 활용해야 의미가 있는 것 같다.  
현재 기술력으로는 교육적인 목적과 보조 도구의 역할에 한정해 사용해야하는 것 같다.  
  
  
  
관련해서 뉴옥 타임즈의 기자 Kevin Roose는 바이브 코딩으로 여러 소규모 애플리케이션을 만들었는데  
프로그래머가 아닌 사람도 기능적 소프트웨어를 생성할 수 있지만 그 결과가 제한적이고 오류가 발생하기 쉽다는 점을 지적하며 
중요한 작업보다는 취미 프로젝트에 더 적합하다고 [기사](https://web.archive.org/web/20250303174203/https://www.nytimes.com/2025/02/27/technology/personaltech/vibecoding-ai-software-programming.html){:target="_blank"}를 작성하였다.



## 프로그래머로 살아가기 위해서
[비야네 스트로스트룹의 견해](https://zdnet.co.kr/view/?no=20250512100248){:target="_blank"}로 정답처럼 보이는 코드'에 의존하는 개발자들이 늘어날수록 프로그래밍의 본질인 문제 인식과 추상화 설계 능력은 퇴화할 수밖에 없다고 경고했다.  
좋은 개발자는 문제를 정의하고 그에 맞는 모델을 구성할 수 있어야 한다"며 "코딩은 그 결과물에 불과하다며 문제 인식 자체를 AI에 위임하는 순간 개발자는 더 이상 기술자가 아니다"고 단언했다.


프로그래머에게 필요한 능력은 지속적으로 변화하며 다양한 부분을 요구했다.  
- 1940년 이전: 물리적 케이블과 스위치 연결 → 전기공학 지식 필요  
- 1940~50년대: 천공 카드/테이프 이용 → 기계어와 이진법 이해 필요  
- 1950년대: 어셈블리어 등장 → CPU, 메모리, 레지스터의 깊은 이해 필요  
- 1960년대: 컴파일 언어 등장 → 알고리즘 설계 능력 중요  
- 1970년대: C언어와 구조적 프로그래밍 → 구조적 사고와 모듈화 능력 필요  
- 1980년대: 객체지향 프로그래밍 → 추상화, 모델링, 디자인 패턴 능력 필요  
- 1990년대: 웹 개발 시대 → 클라이언트-서버, 네트워크, 프로토콜 지식 필요  
- 2000년대: 오픈소스 확산 → 프레임워크 활용과 라이브러리 재사용 능력 중요  
- 2010년대: 인프라 추상화 → DevOps와 클라우드 아키텍처 설계 능력 중요  
- 2020년대: AI 도구 등장 → 노코드/로우코드와 AI 활용 능력 중요  

발전의 공통 패턴  
1. 추상화 수준의 지속적 향상  
하드웨어 → 어셈블리 → 고급언어 → 프레임워크 → AI  

2. 접근성의 확대  
전문가 → 프로그래머 → 일반 개발자 → 비전문가  

3. 협업과 재사용  
개인 작업 → 팀 개발 → 오픈소스 → AI 협업  

변하지 않는 것  
- 문제 정의 능력: 무엇을 어떻게 만들지 결정하는 것  
- 창의적 사고: 새로운 해결책과 접근법 발견  
- 사용자 경험 설계: 인간의 니즈를 이해하고 충족  


기술적 실업으로 MAGA, FAANG에서 시니어 프로그래머들이 해고되는 시대에 '코드 몽키'가 되지 않기 위해서는 기존 개발 지식과 더불어 AI 관련 지식과 활용 능력 그리고 더 폭넓은 영역의 지식을 학습해야 할 것 같다.  
![코드몽키](https://i.namu.wiki/i/ZedeElFQND3GIxRQyk0uJ5Oncs0_fl0IYy7ipKQoL2XYkw6B4o8sgIG5tFk4mQ3fHIqbzzIT6Nb-_VpsASOtQKQottp6uc2Oc8bXEmDCGDKaaasG-iWva_myR2ibkvmzUTblYHqGwSJH5IvnUYuSUQ.webp)

---  
  
