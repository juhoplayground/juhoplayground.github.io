---
layout: post
title: PostgreSQL PL/pgSQL - Index Type
author: 'Juho'
date: 2024-02-15 09:00:00 +0900
categories: [PostgreSQL, Database, Index]
tags: [PostgreSQL, Database, Index]
pin: True
toc : True
---

<style>
  th{
    font-weight: bold;
    text-align: center;
    background-color: white;
  }
  td{
    background-color: white;
  }

</style>

## 목차
1. [Index Type](#index-type)
2. [B-Tree](#b-tree)
3. [Hash](#hash)
4. [Gist](#gist)

## Index Type
PostgreSQL에는 B-Tree, HASH, GiST, SP-GiST, GIN, BGIN, 그리고 확장 기능으로 bloom으로 총 7개의 인덱스 유형을 가지고 있다.<br/>
`CREATE INDEX`는 기본적으로 가장 일반적인 상황에 적합한 B-Tree 인덱스를 생성한다.<br/>
다른 인덱스 유형을 사용하려면 `USING` 다음에 사용하려는 인덱스 유형을 추가해야한다.<br/>
```sql
CREATE INDEX index_name on table_name USING index_type(column_name);
```

## B-Tree
B-tree는 어떤 순서로 정렬될 수 있는 데이터에 대한 동등 및 범위 쿼리를 처리할 수 있다.<br/>
PostgreSQL 쿼리 플래너는 index에 포함된 열이 `<   <=   =   >=   >` 중 하나의 연산자를 사용하여 비교할 때 항상 B-Tree 인덱스를 사용할 것을 고려한다.<br/>
이러한 연산자의 조합과 동등한 구성요소 ex) `Between`, `In`도 B-Tree 인덱스 검색으로 구옇할 수 있다.<br/>
또한 인덱스 열에 대한 `IS NULL` 또는 `IS NOT NULL` 조건은 B-Tree 인덱스와 함깨 사용될 수 있다.<br/>

옵티마이저는 패턴 일치 연산자 `LIKE`와 `~`을 사용하는 쿼리에도 B-Tree 인덱스를 사용할 수 있다.<br/>
단, 패턴이 상수이고 문자열의 시작 부분에 고정된 경우에만 사용할 수 있다.<br/>
예를 들어 col LIKE 'foo%' 혹은 col ~ ''^foo'는 사용이 가능하지만
col LIKE '%bar'는 사용할 수 없다. <br/>
데이터베이스가 C locale을 사용하지 않는 경우 패턴 일치 쿼리의 인덱싱을 지원하기 위해 특별한 연산자 클래스로 인덱스를 생성해야 할 수 있다.<br/>
locale은 initdb를 이용해 클러스터를 구성하면 자동으로 초기화된다.<br/>
특별히 옵션을 넣지 않으면 `en_US.UTF8`로 설정이 된다.
<table>
  <tr>
      <td>LC_COLLATE</td>
      <td>String 정렬 순서</td>
  </tr>
  <tr>
      <td>LC_CTYPE</td>
      <td>문자 분류 (어떤글자인지, 대문자도 동일한지)</td>
  </tr>
  <tr>
      <td>LC_MESSAGES</td>
      <td>메세지 언어</td>
  </tr>
  <tr>
      <td>LC_MONETARY</td>
      <td>통화 형식</td>
  </tr>
  <tr>
      <td>LC_NUMERIC</td>
      <td>숫자 형식</td>
  </tr>
  <tr>
      <td>LC_TIME</td>
      <td>날짜 및 시간 형식</td>
  </tr>
</table>
LC_COLLATE을 C로 설정하지 않으면 문자 처리가 느려지고, LIKE에서 사용되는 일반 인덱스를 사용하지 못한다.<br/>
locale 설정은 다음과 같은 SQL 기능에 영향을 준다.<br/>
1. order by를 사용한 쿼리에서 정렬 순서<br/>
2. 텍스트 데이터에서 표준 비교 연산자<br/>
3. upper, lower, initcap 함수<br/>
4. 패턴일치 연산자<br/>
5. TO_CHAR 계열 함수<br/>
6. LIKE를 사용한 인덱스 사용 능력<br/>
이러한 이유로 필요한 경우에만 locale 설정을 변경해야한다.<br/>
<br/>
`SHOW LC_COLLATE;`을 실행하면 해당 옵션의 설정을 확인할 수 있다.<br/>

B-Tree 인덱스는 데이터를 정렬된 순서로 검색하는데도 사용할 수 있다.<br/>
이것이 항상 간단한 스캔 및 정렬보다 빠르지는 않지만, 간혹 도움이 된다.<br/>

## Hash
Hash 인덱스는 index에 포함된 열의 값으로 생성된 32비트 해시 코드를 저장한다.<br/>
쿼리 플래너는 인덱스된 열이 `=` 연산자를 사용하여 비교할때 해시 인덱스를 사용할 것을 고려한다. <br/>

## GiST
GiSt는 일반화된 검색 트리(Generalized Search Tree)다.<br/>
균형 잡힌 트리 구조의 접근 방법으로서, 임의의 인덱스 방식을 구현하기 위한 기본 템플릿 역활을 한다.<br/>
B트리, R트리 및 많은 다른 인덱스 방식을 GiST로 구현할 수 있다.<br/>
GiST의 장점은 데이터 유형에 적합한 엑세스 방법을 사용하여 사용자 정의 데이터 유형의 개발이 가능한 것이다.<br/>
여러 종류의 2차원 기하 데이터 유형을 위한 GiST 연산자 클래스가 포함되어 있고
다음과 같은 연산자를 사용하는 쿼리를 지원한다.<br/>
```
<<   &<   &>   >>   <<|   &<|   |&>   |>>   @>   <@   ~=   &&
```
GiST 인터페이스는 높은 수준의 추상화를 갖추고 있어서, 엑세스 방법 구현자가 엑세스하는 데이터 유형의 의미론만 구현하면 된다.<br/>
GiST 레이어 자체가 동시성, 로깅 및 트리 구조 검색을 처리한다.<br/>
GiST 기반 인덱스를 사용하면 도메인별 질문을 할 수 있는 쿼리를 만들 수 있다.<br/>
<br/>
Gist 엑세스 방법을 실행하고, 실행하기 위해 필요한 것은 트리에 있는 키의 동작을 정의하는 여러 사용자 정의 방법을 구현하는 것 이다.<br/>
물론 이러한 메소드는 고급 쿼리를 지원하기 위해 꽤 복잡해야 하지만, 표준 쿼리(B-Tree, R-Tree)에 대해서는 비교적 간단하다. <br/>
<br/>
GiST를 위한 인덱스 연산자 클래스는 다섯 가지 메서드를 제공해야 하며, 선택적으로 여섯 가지 메서드를 제공할 수 있다.<br/>
인덱스의 정확성은 같은 메서드, 일관된 메서드 및 합집합 메서드의 적절한 구현에 의해 보장되며, 인덱스의 효율성(크기 및 속도)은 패널티 메서드 및 픽스플릿 메서드에 따라 달라진다.<br/>
선택적으로 사용할 수 있는 두 가지 메서드는 압축 및 압축 해제이며, 이를 통해 인덱스가 인덱싱하는 데이터와 다른 유형의 내부 트리 데이터를 가질 수 있다.<br/>
리프는 인덱싱된 데이터 유형이어야 하며, 다른 트리 노드는 모든 C 구조체일 수 있습니다.<br/>
트리의 내부 데이터 유형이 SQL 수준에서 존재하는 경우, CREATE OPERATOR CLASS 명령의 STORAGE 옵션을 사용할 수 있다.<br/>
선택적 메서드 중 8번째는 연산자 클래스가 순서화된 스캔(가장 가까운 이웃 검색)을 지원하려는 경우 필요하다.<br/>
선택적 메서드 중 9번째는 fetch로 압축 메서드가 생략된 경우에는 인덱스 전용 스캔을 지원하려는 경우 필요하다.<br/>
선택적 메서드 중 10번째는 optsions로 연산자 클래스에 사용자 지정 매개 변수가 있는 경우 필요하다.<br/>
선택적 메서드 중 11번째 sortsupport는 GiST 인덱스를 빌드하는 속도를 높이기 위해 사용된다.<br/>
<br/>
Gist 인덱스를 구현하는 가장 간단한 방법은 모든 항목을 하나씩 삽입하는 것인데, 이 방법은 대규모 인덱스에 대해 속도가 느릴 수 있다.<br/>
냐하면 인덱스 튜플이 인덱스 전체에 흩어져 있고, 인덱스가 캐시에 들어갈만큼 충분히 크다면, 많은 랜덤 I/O가 필요하기 때문이다.<br/>
PostgreSQL은 GiST 인덱스의 초기 빌드를 위해 두 가지 대체 방법을 지원하는데, `sorted`와 `buffered`이다.<br/>
<br/>
`sorted` 모드는 각 opclass가 인덱스에 제공하는 sortsupport 함수를 제공하는 경우에만 사용할 수 있다.<br/>
이 방법이 일반적으로 가장 좋기 때문에 기본적으로 사용된다.<br/>
<br/>
`buffered` 모드는 튜플을 즉시 인덱스에 직접 삽입하지 않고 작동한다.<br/>
이 방법은 비순서화된 데이터 세트에 필요한 랜덤 I/O 양을 현저하게 줄일 수 있다.<br/>
잘 정렬된 데이터 세트의 경우 혜택이 작거나 없을 수 있다.<br/>
왜냐하면 한 번에 새로운 튜플을 받는 페이지 수가 매우 적기 때문에 해당 페이지들은 캐시에 들어가며 전체 인덱스가 캐시에 들어가지 않더라도 이득을 볼 수 있다.<br/>
`buffered` 모드는 단순한 방법보다 패널티 함수를 더 자주 호출해야 하므로 약간의 추가 CPU 자원을 소비한다.<br/> 
또한 버퍼에는 결과 인덱스의 크기만큼의 임시 디스크 공간이 필요하다.<br/> 버퍼링은 결과 인덱스의 품질에도 긍정적이거나 부정적인 영향을 미칠 수 있다.<br/>
이 영향은 입력 데이터의 분포 및 연산자 클래스 구현과 같은 여러 요소에 따라 달라진다.<br/>
<br/>
정렬이 불가능한 경우, GiST 인덱스 빌드는 기본적으로 인덱스 크기가 `effective_cache_size`에 도달할 때 버퍼링 방법으로 전환된다.<br/>
버퍼링은 `CREATE INDEX`의 buffering 매개변수를 사용하여 수동으로 강제하거나 방지할 수 있다.<br/>
기본 동작은 대부분의 경우에 적합하지만 입력 데이터가 정렬되어 있는 경우 버퍼링을 비활성화하면 빌드 속도가 약간 빨라질 수 있다.<br/>
