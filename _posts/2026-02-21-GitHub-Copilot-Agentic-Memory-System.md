---
layout: post
title: "AI는 왜 5분 전 말을 까먹을까 - GitHub Copilot의 에이전틱 메모리 시스템"
author: 'Juho'
date: 2026-02-21 02:00:00 +0900
categories: [AI]
tags: [AI, LLM, Dev]
pin: True
toc: True
---

<style>
  th{
    font-weight: bold;
    text-align: center;
    background-color: white;
  }
  td{
    background-color: white;
  }
</style>

## 목차
1. [개요](#개요)
2. [AI 에이전트의 근본적 한계 - 무상태성](#ai-에이전트의-근본적-한계---무상태성)
3. [GitHub Copilot의 에이전틱 메모리 아키텍처](#github-copilot의-에이전틱-메모리-아키텍처)
4. [메모리 관리 메커니즘](#메모리-관리-메커니즘)
5. [크로스 에이전트 메모리 공유](#크로스-에이전트-메모리-공유)
6. [접근 권한과 보안](#접근-권한과-보안)
7. [직접 구축 vs 기존 솔루션 활용](#직접-구축-vs-기존-솔루션-활용)
8. [메모리 시스템의 기술적 구성 요소](#메모리-시스템의-기술적-구성-요소)
9. [결론](#결론)
10. [Reference](#reference)

## 개요

AI 코딩 어시스턴트의 가장 큰 한계 중 하나는 대화가 끝나면 모든 맥락을 잊어버린다는 것이다.
새 세션을 시작할 때마다 "처음 만난 사람" 상태로 돌아가서, 개발자는 이미 설명한 코딩 컨벤션, 아키텍처 패턴, 저장소 고유 지식을 반복해서 전달해야 한다.

GitHub은 이 문제를 해결하기 위해 Copilot에 에이전틱 메모리(Agentic Memory) 시스템을 도입했다.
Supermemory는 이러한 AI 메모리 시스템을 직접 구축할 것인지 기존 솔루션을 활용할 것인지에 대한 실질적인 판단 기준을 제시했다.

## AI 에이전트의 근본적 한계 - 무상태성

대규모 언어 모델의 구조적 제약은 상태를 유지하지 못한다는 것이다.
대화가 종료되면 컨텍스트 윈도우에 있던 모든 정보가 사라진다.

이로 인해 발생하는 문제들이 있다.

- 개발자가 이미 제공한 정보를 반복해서 요청한다
- 프로젝트 고유의 패턴이나 규칙을 매번 다시 학습해야 한다
- 이전 세션에서 발견한 해결책을 기억하지 못한다

이 문제를 해결하려면 대화 로그를 저장하는 것이 아니라, 의미 있는 정보를 구조화해서 관리하는 메모리 시스템이 필요하다.

## GitHub Copilot의 에이전틱 메모리 아키텍처

GitHub Copilot은 세 개의 계층으로 구성된 메모리 시스템을 구축했다.

### 수집 계층 (Collection Layer)

시스템이 대화에서 의미 있는 정보를 자동으로 추출한다.
개발자가 "Python으로 작업하고 있다"고 말하면, 이를 단순한 대화 텍스트가 아닌 사용자 선호도로 캡처한다.

### 저장 계층 (Storage Layer)

추출된 정보는 PostgreSQL에 카테고리별로 정리되어 저장된다.
단순 대화 로그가 아니라 "사용자 선호", "프로젝트 컨텍스트", "이전 해결책" 같은 범주로 구조화된다.

### 검색 계층 (Retrieval Layer)

벡터 검색과 키워드 검색을 결합한 하이브리드 방식으로 관련 정보를 빠르게 찾는다.
예를 들어 "React 컴포넌트 리팩토링" 요청이 들어오면, 해당 사용자가 이전에 함수형 컴포넌트를 선호한다고 표현한 기억을 불러온다.

### 우선순위 체계

GitHub은 메모리에 가중치를 부여하는 세 가지 기준을 사용한다.

| 기준 | 설명 |
|------|------|
| 최신성 (Recency) | 최근 대화가 오래된 대화보다 높은 우선순위를 가진다 |
| 빈도 (Frequency) | 자주 언급된 정보가 높은 순위를 받는다 |
| 명시성 (Explicitness) | 명시적으로 표시된 항목이 최우선 처리된다 |

## 메모리 관리 메커니즘

### 인용 기반 검증

각 메모리는 특정 코드 위치를 가리키는 인용(citation)을 포함한다.
Copilot이 메모리를 검색할 때 현재 코드베이스를 기준으로 인용을 검증한다.
검증에 성공하고 실제로 사용되면, 동일한 내용의 새 메모리가 저장되어 수명이 연장된다.

### 자동 만료

메모리는 검증 없이 28일이 지나면 자동으로 삭제된다.
이를 통해 구식 정보가 유지되면서 Copilot의 의사결정에 부정적 영향을 미치는 것을 방지한다.

### 저장소 범위 제한

메모리는 사용자 단위가 아닌 저장소 단위로 격리된다.
"Copilot이 저장소에 대해 학습한 것은 해당 저장소 안에 머문다."
다른 저장소나 조직으로 메모리가 전이되지 않는다.

## 크로스 에이전트 메모리 공유

에이전틱 메모리의 핵심 기능 중 하나는 Copilot 내부의 서로 다른 에이전트 간 메모리 공유다.

예를 들어 Copilot 코딩 에이전트가 저장소의 데이터베이스 연결 처리 방식을 학습하면, Copilot 코드 리뷰가 나중에 풀 리퀘스트를 검토할 때 이 지식을 활용해 일관성 없는 패턴을 발견할 수 있다.

현재 에이전틱 메모리를 사용하는 컴포넌트는 다음과 같다.

| 컴포넌트 | 설명 |
|----------|------|
| Copilot 코딩 에이전트 | 코드 작성 시 저장소 패턴 학습 |
| Copilot 코드 리뷰 | PR 리뷰 시 학습된 패턴 적용 |
| Copilot CLI | 명령줄에서의 메모리 활용 |

## 접근 권한과 보안

에이전틱 메모리는 기본적으로 비활성화되어 있다.
엔터프라이즈, 조직 또는 개인 설정 수준에서 명시적으로 활성화해야 한다.

메모리를 생성할 수 있는 사용자는 해당 저장소에 쓰기 권한이 있는 기여자로 제한된다.
저장소의 Copilot Memory 접근 권한이 있는 모든 사용자는 해당 저장소의 메모리를 활용할 수 있다.

### 이용 가능 플랜

| 플랜 | 지원 여부 |
|------|-----------|
| Copilot Enterprise | 지원 |
| Copilot Business | 지원 |
| Copilot Pro / Pro+ | 지원 |

현재 Public Preview 상태로 제공되고 있다.

## 직접 구축 vs 기존 솔루션 활용

Supermemory는 AI 메모리 시스템의 직접 구축 여부를 결정하는 실질적인 기준을 제시했다.

### 직접 구축이 적합한 경우

- 도메인 특화 요구사항이 있는 경우 (금융, 의료, 법률)
- 메모리 기능이 제품의 핵심 경쟁력인 경우
- 데이터에 대한 완전한 통제가 필수적인 경우

### 기존 솔루션 활용이 적합한 경우

- MVP 출시 속도가 중요한 경우
- 엔지니어링 리소스가 제한적인 경우
- 챗봇이나 개인 비서 같은 표준 유스케이스인 경우

Supermemory의 핵심 권고는 다음과 같다.
"기존 솔루션으로 시작하고, 진짜 필요할 때만 직접 구축으로 전환하라."

### 직접 구축의 실제 비용

프로덕션 수준의 메모리 시스템 구축에는 수 주의 구현과 수 개월의 튜닝이 필요하다.
그것도 스케일 문제를 다루기 전의 이야기다.

직접 구축할 경우 해결해야 할 기술적 과제들이 있다.

- 검색 품질 - 정리되지 않은 사용자 데이터에서의 정확한 검색
- 청킹과 추출 로직 설계
- 랭킹과 중복 제거
- 환각 방지 필터링
- 지연 시간 제약 충족
- 회귀 테스트 - 메모리 품질은 조용히 저하되기 때문

## 메모리 시스템의 기술적 구성 요소

프로덕션 메모리 시스템을 구축하려면 여러 시스템을 통합해야 한다.

| 구성 요소 | 역할 |
|-----------|------|
| 벡터 데이터베이스 | 저장 및 유사도 검색 |
| 임베딩 모델 | 텍스트를 벡터로 변환 |
| LLM / 텍스트 모델 | 추론 및 압축 |
| 추출 서비스 | 청킹, 파싱, 보강 |

Supermemory는 대부분의 오픈소스 메모리 시스템이 데모에서는 잘 작동하지만 실제 사용자가 사용하면 품질이 급격히 저하된다고 지적했다.
평가 체계, 확장성, 기본 설정 모두에서 한계를 보인다는 것이다.

## 결론

AI 에이전트의 메모리 문제는 단순한 기술적 과제가 아니라 제품 차별화의 핵심으로 부상하고 있다.
GitHub Copilot은 저장소 단위의 구조화된 메모리와 자동 검증 메커니즘으로 이 문제를 해결하고 있다.

경쟁의 축이 변하고 있다.
"얼마나 똑똑한가"에서 "나를 얼마나 잘 이해하는가"로의 전환이다.
메모리 시스템은 AI를 도구에서 협업 파트너로 변화시키는 핵심 인프라가 되고 있다.

## Reference

- [About agentic memory for GitHub Copilot - GitHub Docs](https://docs.github.com/en/copilot/concepts/agents/copilot-memory)
- [Should You Build Your Own AI Memory System? - Supermemory Blog](https://blog.supermemory.ai/should-you-build-your-own-ai-memory-system/)
